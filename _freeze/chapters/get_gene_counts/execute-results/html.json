{
  "hash": "0a78052248e45ad9515146cb86f95ed2",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute: \n  echo: true\n  eval: false\n  warning: false\n---\n\n\n# Data preprocessing for Computational Analysis of gene Family Evolution\n\nThe purpose of this script is to generate the data needed for the analysis of gene family evolution in angiosperms. The output files are a CSV file with the number of genes per family and species, and a phylogenetic tree in the correct format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\nlibrary(dbplyr)\nlibrary(tidyverse)\nlibrary(readr)\nlibrary(rotl)\nlibrary(ape)\nlibrary(ggtree)\nlibrary(ggplot2)\nlibrary(cowplot)\nlibrary(RColorBrewer)\nlibrary(ape)\nlibrary(tidytree)\n\nset.seed(123) # for reproducibility\n```\n:::\n\n\n## Download gene families from PLAZA\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfamilies_dicots <- read_tsv(\n  \"https://ftp.psb.ugent.be/pub/plaza/plaza_public_dicots_05/GeneFamilies/genefamily_data.HOMFAM.csv.gz\", \n  comment = \"# \"\n)\ncolnames(families_dicots) <- c(\"family\", \"species\", \"gene_id\")\n\nfamilies_monocots <- read_tsv(\n  \"https://ftp.psb.ugent.be/pub/plaza/plaza_public_monocots_05/GeneFamilies/genefamily_data.HOMFAM.csv.gz\", \n  comment = \"# \"\n)\ncolnames(families_monocots) <- c(\"family\", \"species\", \"gene_id\")\n\n# join\nfamilies <- bind_rows(families_dicots, families_monocots)\n\n# get correspondence between dicots and monocots based on gene id\nfamilies_lookup <- families_dicots %>%\n  inner_join(families_monocots, by = c(\"species\", \"gene_id\")) %>%\n  rename(family_dicots = family.x, family_monocots = family.y) %>%\n  select(family_monocots, family_dicots)\n\n# remove duplicates\nfamilies_lookup <- families_lookup[!duplicated(families_lookup), ]\n\nhead(families_lookup)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 2\n  family_monocots family_dicots\n  <chr>           <chr>        \n1 HOM05M000001    HOM05D000001 \n2 HOM05M001698    HOM05D000001 \n3 HOM05M000725    HOM05D000001 \n4 HOM05M002008    HOM05D000001 \n5 HOM05M000646    HOM05D000001 \n6 HOM05M001340    HOM05D000001 \n```\n\n\n:::\n:::\n\n\nCount genes per family and species in both dicots and monocots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndicots_count <- families_dicots %>%\n  group_by(family, species) %>%\n  summarise(n_genes = n()) %>%\n  ungroup()\n\nhead(dicots_count)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmonocots_count <- families_monocots %>%\n  group_by(family, species) %>%\n  summarise(n_genes = n()) %>%\n  ungroup()\nhead(monocots_count)\n```\n:::\n\n\nMatch the lookup table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join dicots with lookup to get corresponding monocot families\ndicots_joined <- dicots_count %>%\n  rename(family_dicots = family, n_dicots = n_genes) %>%\n  left_join(families_lookup, by = \"family_dicots\")\n\n# Join monocots with lookup to get corresponding dicot families\nmonocots_joined <- monocots_count %>%\n  rename(family_monocots = family, n_monocots = n_genes) %>%\n  left_join(families_lookup, by = \"family_monocots\")\n\n# Full join both to preserve dicot-only, monocot-only, or shared families\ncombined_counts <- full_join(\n  dicots_joined,\n  monocots_joined,\n  by = c(\"species\", \"family_dicots\", \"family_monocots\")\n) %>%\n  select(species, family_monocots, family_dicots, n_monocots, n_dicots)\n\n# Create a table of unique family combinations and assign a stable group ID\nfamily_groups <- combined_counts %>%\n  select(family_dicots, family_monocots) %>%\n  distinct() %>%\n  arrange(family_dicots, family_monocots) %>%\n  mutate(family_group_id = row_number())\n\n# Add family_group_id back to the combined data\ncombined_counts <- combined_counts %>%\n  left_join(family_groups, by = c(\"family_dicots\", \"family_monocots\"))\n\n# View result\nhead(combined_counts)\n```\n:::\n\n\n\nSave to csv:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(combined_counts, \"../data/combined_counts.csv\")\n```\n:::\n\n\n### Adding metadata\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_metadata <- read.table(\"../data/species_metadata_PLAZA.tsv\", sep = \"\\t\", header=TRUE)\n\npr_genes <- combined_counts |>\n  left_join(species_metadata, by = c(\"species\" = \"species\"))\n\nhead(pr_genes)\n```\n:::\n\n\n## Format the phylogenetic tree\n\nRead the tree nd remove species not in the gene families:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntree <- readRDS(\"../data/angiowgd_tree.rds\")\n\ntree_phylo <- as.phylo(tree)\n\n# get species list from pr_genes\nspecies_list <- unique(pr_genes$name)\n\nspecies_to_keep_mod <- gsub(\" \", \"_\", species_list)\n\n# compute species in species_to_keep_mod that are not in the tree\nspecies_not_in_tree <- species_to_keep_mod[ ! species_to_keep_mod %in% tree_phylo$tip.label]\n\nspecies_in_tree <- species_to_keep_mod[species_to_keep_mod %in% tree_phylo$tip.label]\nspecies_in_tree <- species_in_tree[order(species_in_tree)]\n\ntips_to_drop <- tree_phylo$tip.label[ ! tree_phylo$tip.label %in% species_to_keep_mod]\nsubset_tree <- drop.tip(tree_phylo, tips_to_drop)\n\nprint(subset_tree)\n```\n:::\n\n\nMake sure the tree is rooted, binary, and ultrametric. Then save the tree in newick format:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check current tree properties\ncat(\"Initial tree properties:\\n\")\ncat(\"  Rooted:      \", is.rooted(subset_tree), \"\\n\")\ncat(\"  Binary:      \", is.binary(subset_tree), \"\\n\")\ncat(\"  Ultrametric: \", is.ultrametric(subset_tree), \"\\n\\n\")\n\n# 1. Ensure the tree is rooted\nif (!is.rooted(subset_tree)) {\n  cat(\"Tree is not rooted. Rooting the tree...\\n\")\n  # Here, we're using the first tip as an example outgroup.\n  # Replace with an appropriate outgroup if necessary.\n  subset_tree <- root(subset_tree, outgroup = \"Glycine_max\", resolve.root = TRUE)\n}\n\n# 2. Ensure the tree is binary (fully bifurcating)\nif (!is.binary(subset_tree)) {\n  cat(\"Tree is not binary. Resolving polytomies...\\n\")\n  subset_tree <- multi2di(subset_tree)\n}\n\n# 3. Ensure the tree is ultrametric\nif (!is.ultrametric(subset_tree)) {\n  cat(\"Tree is not ultrametric. Converting tree to ultrametric using chronos...\\n\")\n  # 'chronos' uses a relaxed clock model to produce an ultrametric tree.\n  subset_tree <- chronos(subset_tree)\n}\n\n# Check properties again after processing\ncat(\"\\nProcessed tree properties:\\n\")\ncat(\"  Rooted:      \", is.rooted(subset_tree), \"\\n\")\ncat(\"  Binary:      \", is.binary(subset_tree), \"\\n\")\ncat(\"  Ultrametric: \", is.ultrametric(subset_tree), \"\\n\\n\")\n\n# Save the tree in Newick format\nwrite.tree(subset_tree, file = \"../data/subset_tree.txt\")\ncat(\"Tree saved to 'subset_tree.newick'\\n\")\n```\n:::\n",
    "supporting": [
      "get_gene_counts_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}